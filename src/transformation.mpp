export module transformation;
import tool;
import input;
import resource;
import context;
import <stl>;
import <gl>;
import <glm>;

export namespace minecpp
{
   
inline glm::mat4 newViewModel(const glm::vec3& position, const glm::vec3& target = glm::vec3(0.0f), const glm::vec3& up = glm::vec3(0.0f, 1.0f, 0.0f)){
   // 从相机的方向上看过去，其右边是x轴正方向，上边是y轴正方向，前边是z轴反方向
   // 使用glm::lookAt方法，给定相机位置、目标（相机对准的地方，z轴反方向）与y轴方向（都是相对于世界坐标系），得到相机的view矩阵
   // 参数无需单位化
   return glm::lookAt(position, target - position, up);
}
inline glm::mat4 newModel(const glm::vec3& location, const glm::vec3& scale){
   return glm::translate(glm::mat4(1.0f), location) * glm::scale(scale);
}
inline glm::mat4 newModel(const glm::vec3& location = glm::vec3(), float scale = 1.0f){
   return newModel(location, glm::vec3(scale, scale, scale));
}


class ModelController{
private:
   ObservableValue<glm::mat4>* model;
public:
   bool isSelf;

   ModelController(ObservableValue<glm::mat4>* model, bool isSelf = false): model(model), isSelf(isSelf){}
   ModelController(bool isSelf = false): ModelController(nullptr, isSelf){}
   // model必须是空间矩阵，否则是未定义行为
   ModelController(ObservableValue<glm::mat4>& model, bool isSelf = false): ModelController(&model, isSelf){}
   ModelController& operator=(ObservableValue<glm::mat4>* model){
      this->model = model;
      return *this;
   }
   ModelController& operator=(ObservableValue<glm::mat4>& model){
      return this->operator=(&model);
   }
   void translate(const glm::vec3& vec){
      if(isSelf){
         **model = model->get() * glm::translate(vec);
         model->mayNotify();
      }else{
         // 空间矩阵相对于目标坐标系进行平移
         **model = glm::translate(vec) * model->get();
         model->mayNotify();
      }
   }
   void translateX(float delta){
      translate({delta, 0.0f, 0.0f});
   }
   void translateY(float delta){
      translate({0.0f, delta, 0.0f});
   }
   void translateZ(float delta){
      translate({0.0f, 0.0f, delta});
   }
   // 可以不是 normalize 的
   void rotate(float angle, const glm::vec3& axis){
      if(isSelf){
         // 空间矩阵相对于自己进行旋转
         **model = model->get() * glm::mat4_cast(glm::angleAxis(glm::radians(angle), glm::normalize(axis)));
         // 这种方式效果也是一样的
         // **model = glm::rotate(model->get(), glm::radians(angle), axis);
         model->mayNotify();
      }else{
         // 空间矩阵相对于目标坐标系进行旋转
         **model = glm::mat4_cast(glm::angleAxis(glm::radians(angle), glm::normalize(axis))) * model->get();
         model->mayNotify();
      }
   }
   void rotateX(float angle){
      rotate(angle, glm::vec3(1.0f, 0.0f, 0.0f));
   }
   void rotateY(float angle){
      rotate(angle, glm::vec3(0.0f, 1.0f, 0.0f));
   }
   void rotateZ(float angle){
      rotate(angle, glm::vec3(0.0f, 0.0f, 1.0f));
   }
};

class ModelComputer{
public:
   static glm::vec3 computePosition(const glm::mat4& model){
      return glm::vec3(model[3]);
   }
   static glm::vec3 computeScale(const glm::mat4& model){
      return glm::vec3 {
         glm::length(glm::vec3(model[0])),
         glm::length(glm::vec3(model[1])),
         glm::length(glm::vec3(model[2]))
      };
   }
   static glm::vec3 computeViewPosition(const glm::mat4& viewModel){
      return glm::vec3(glm::inverse(viewModel)[3]);
   }
   static glm::mat3 computeNormalModel(const glm::mat4& model){
      return glm::mat3(glm::transpose(glm::inverse(model)));
   }
};

class ModelTransMeta{
public:
   ObservableValue<glm::vec3> scale;
   ObservableValue<glm::vec3> position;
   ObservableValue<glm::vec3> axis;
   ObservableValue<float> angle;
};

class ModelTrans: public ModelTransMeta, public ReactiveValue<glm::mat4, glm::vec3, glm::vec3, glm::vec3, float>{
private:
   using ReactiveModelTrans = ReactiveValue<glm::mat4, glm::vec3, glm::vec3, glm::vec3, float>;

   ReactiveModelTrans createModelTrans(){
      return {[](const glm::vec3& scale, const glm::vec3& position, const glm::vec3& axis, float angle){
         return 
               glm::translate(position) * 
               glm::rotate(glm::mat4(1.0f), glm::radians(angle), axis) * 
               glm::scale(scale);
      }, scale, position, axis, angle};
   }
public:
   ModelTrans(const glm::vec3 position): 
      ModelTransMeta{.scale = glm::vec3{1.0f, 1.0f, 1.0f}, .position = position, .axis = glm::vec3{1.0f, 0.0f, 0.0f}},
      ReactiveModelTrans(createModelTrans()){}

   ModelTrans& operator=(const ModelTrans& coord) {
      ModelTrans::operator=(coord);
      // ReactiveModelTrans::operator=(createModelTrans());
      return *this;
   }
   ModelTrans(const ModelTrans& coord) :
      ModelTransMeta(coord), ReactiveModelTrans(createModelTrans()){};
   
   ModelTrans& operator=(ModelTrans&& coord) {
      ModelTrans::operator=(std::move(coord));
      // ReactiveModelTrans::operator=(createModelTrans());
      return *this;
   }
   ModelTrans(ModelTrans&& coord) :
      ModelTransMeta(std::move(coord)), ReactiveModelTrans(createModelTrans()){};
};


class ProjectionMeta{
public:
   ObservableValue<float> fovy;
   ObservableValue<float> near;
   ObservableValue<float> far;
};

class ProjectionTrans: public ProjectionMeta, public ReactiveValue<glm::mat4, int, int, float, float, float>{
public:
   using ReactiveProjection = ReactiveValue<glm::mat4, int, int, float, float, float>;
   // ReactiveProjection projection;
private:
   ReactiveProjection createProjectionTrans(){
      return {
         [](auto width, auto height, auto fovy, auto near, auto far){
            return glm::perspective(glm::radians(fovy), width * 1.0f / height , near, far);
         }, 
         Context::getInstance().getWidth(), Context::getInstance().getHeight(), this->fovy, this->near, this->far
      };
   }
public:
   ProjectionTrans(float fovy = 45.0f, float near = 0.1f, float far = 100.0f):
      ProjectionMeta{.fovy = fovy, .near = near, .far = far},
      ReactiveProjection(createProjectionTrans()){}

   // copy semantic
   ProjectionTrans& operator=(const ProjectionTrans& projectionCoord) {
      // 只需要把元数据拿过来，reactive不变
      ProjectionMeta::operator=(projectionCoord);
      // projection = getReactiveProjection();
      return *this;
   }
   ProjectionTrans(const ProjectionTrans& projectionCoord) :
      ProjectionMeta(projectionCoord),
      ReactiveProjection (createProjectionTrans()){}
   
   // move semantic
   ProjectionTrans& operator=(ProjectionTrans&& projectionCoord) {
      // 只需要把元数据拿过来，reactive不变
      ProjectionMeta::operator=(std::move(projectionCoord));
      // projection = getReactiveProjection();
      return *this;
   }
   ProjectionTrans(ProjectionTrans&& projectionCoord) :
      ProjectionMeta (std::move(projectionCoord)),
      ReactiveProjection (createProjectionTrans()){}

};

class Camera{
public:
  Camera(ObservableValue<glm::mat4> viewTrans, ProjectionTrans projectionTrans)
      : viewTrans(std::move(viewTrans)),
        projectionTrans(std::move(projectionTrans)) {}
  ObservableValue<glm::mat4> viewTrans;
  ProjectionTrans projectionTrans;
};

class CameraControlSetter{
private:
   Camera* camera;

   std::vector<KeyHoldHandler> keyHandlers;
   std::vector<CursorMoveHandler> cursorHandlers;

   
   // 100时1秒走1个单位长度
   int moveSpeed;
   // 100时1秒转一圈（或者鼠标移动整个屏幕转一圈）
   int rotateSpeed;
public:
   float getMoveSpeed() const { return moveSpeed; }
   void setMoveSpeed(float moveSpeed_) { moveSpeed = moveSpeed_; }
   float getRotateSpeed() const { return rotateSpeed; }
   void setRotateSpeed(float rotateSpeed_) { rotateSpeed = rotateSpeed_; }
private:
   float computeMoveDistance(){
      return moveSpeed * Context::getInstance().getFrameDuration() / 1000.0f / 100.0f;
   }
   float computeRotateRadians(){
      return glm::radians(rotateSpeed * Context::getInstance().getFrameDuration() * 360.0f / 1000.0f / 100.0f);
   }
   float computeRotateRadiansYPos(float pos){
      return glm::radians(rotateSpeed * pos * 360.0f / Context::getInstance().getHeight().get() / 100.0f);
   }
   float computeRotateRadiansXPos(float pos){
      return glm::radians(rotateSpeed * pos * 360.0f / Context::getInstance().getWidth().get() / 100.0f);
   }
   void createSetter(){
      keyHandlers.emplace_back(GLFW_KEY_A, [this](auto _){camera->viewTrans = glm::translate(glm::vec3{computeMoveDistance(), 0.0f, 0.0f}) * camera->viewTrans.get();});
      keyHandlers.emplace_back(GLFW_KEY_D, [this](auto _){camera->viewTrans = glm::translate(glm::vec3{-computeMoveDistance(), 0.0f, 0.0f}) * camera->viewTrans.get();});
      keyHandlers.emplace_back(GLFW_KEY_Z, [this](auto _){camera->viewTrans = glm::translate(glm::vec3{0.0f, -computeMoveDistance(), 0.0f}) * camera->viewTrans.get();});
      keyHandlers.emplace_back(GLFW_KEY_X, [this](auto _){camera->viewTrans = glm::translate(glm::vec3{0.0f, computeMoveDistance(), 0.0f}) * camera->viewTrans.get();});
      keyHandlers.emplace_back(GLFW_KEY_W, [this](auto _){camera->viewTrans = glm::translate(glm::vec3{0.0f, 0.0f, computeMoveDistance()}) * camera->viewTrans.get();});
      keyHandlers.emplace_back(GLFW_KEY_S, [this](auto _){camera->viewTrans = glm::translate(glm::vec3{0.0f, 0.0f, -computeMoveDistance()}) * camera->viewTrans.get();});
      keyHandlers.emplace_back(GLFW_KEY_L, [this](auto _){camera->viewTrans = glm::rotate(-computeRotateRadians(), glm::vec3{0.0f, 1.0f, 0.0f}) * camera->viewTrans.get() ;});
      keyHandlers.emplace_back(GLFW_KEY_J, [this](auto _){camera->viewTrans = glm::rotate(computeRotateRadians(), glm::vec3{0.0f, 1.0f, 0.0f}) * camera->viewTrans.get()  ;});
      keyHandlers.emplace_back(GLFW_KEY_I, [this](auto _){camera->viewTrans = glm::rotate(-computeRotateRadians(), glm::vec3{1.0f, 0.0f, 0.0f}) * camera->viewTrans.get() ;});
      keyHandlers.emplace_back(GLFW_KEY_K, [this](auto _){camera->viewTrans = glm::rotate(computeRotateRadians(), glm::vec3{1.0f, 0.0f, 0.0f}) * camera->viewTrans.get()  ;});
      keyHandlers.emplace_back(GLFW_KEY_U, [this](auto _){camera->viewTrans = glm::rotate(-computeRotateRadians(), glm::vec3{0.0f, 0.0f, 1.0f}) * camera->viewTrans.get() ;});
      keyHandlers.emplace_back(GLFW_KEY_O, [this](auto _){camera->viewTrans = glm::rotate(computeRotateRadians(), glm::vec3{0.0f, 0.0f, 1.0f}) * camera->viewTrans.get()  ;});
      cursorHandlers.emplace_back([this](double x, double y){
         camera->viewTrans = glm::rotate(computeRotateRadiansXPos(x), glm::vec3{0.0f, 1.0f, 0.0f}) * camera->viewTrans.get();
         camera->viewTrans = glm::rotate(computeRotateRadiansYPos(y), glm::vec3{1.0f, 0.0f, 0.0f}) * camera->viewTrans.get();
      });
   }
public:
   CameraControlSetter(Camera& camera): camera(&camera), moveSpeed(100), rotateSpeed(100){
      createSetter();
   }

   CameraControlSetter& operator=(CameraControlSetter&& setter){
      camera = setter.camera;
      return *this;
   }
   CameraControlSetter(CameraControlSetter&& setter): camera(setter.camera){
      createSetter();
   }
   // deleted copy semantic
   CameraControlSetter& operator=(const CameraControlSetter&) = delete;
   CameraControlSetter(const CameraControlSetter&) = delete;
};

class ModelMoveSetter{
private:
   std::vector<KeyHoldHandler> keyHandlers;
   std::vector<CursorMoveHandler> cursorHandlers;
   ModelController viewModelController;
   void createSetters(){
      auto add = [this](int key, const std::function<void()>& handler){
         this->keyHandlers.emplace_back(key, [handler](auto _){handler();});
      };
      add(GLFW_KEY_A, [this](){this->viewModelController.translateX(moveSpeed);});
      add(GLFW_KEY_D, [this](){this->viewModelController.translateX(-moveSpeed);});
      add(GLFW_KEY_Z, [this](){this->viewModelController.translateY(-moveSpeed);});
      add(GLFW_KEY_X, [this](){this->viewModelController.translateY(moveSpeed);});
      add(GLFW_KEY_W, [this](){this->viewModelController.translateZ(moveSpeed);});
      add(GLFW_KEY_S, [this](){this->viewModelController.translateZ(-moveSpeed);});
      add(GLFW_KEY_L, [this](){this->viewModelController.rotateY(rotateSpeed);});
      add(GLFW_KEY_J, [this](){this->viewModelController.rotateY(-rotateSpeed);});
      add(GLFW_KEY_I, [this](){this->viewModelController.rotateX(-rotateSpeed);});
      add(GLFW_KEY_K, [this](){this->viewModelController.rotateX(rotateSpeed);});
      add(GLFW_KEY_U, [this](){this->viewModelController.rotateZ(-rotateSpeed);});
      add(GLFW_KEY_O, [this](){this->viewModelController.rotateZ(rotateSpeed);});
      this->cursorHandlers.emplace_back([this](double x, double y){
         this->viewModelController.rotateY(rotateSpeed * x);
         this->viewModelController.rotateX(rotateSpeed * y);
      });
   }
public:
   float moveSpeed = 0.05f;
   float rotateSpeed = 0.1f;
   ModelMoveSetter(ObservableValue<glm::mat4>& viewModel, bool isSelf = false):viewModelController(viewModel, isSelf){
      createSetters();
   }
   void isSelf(bool isSelf){
      viewModelController.isSelf = isSelf;
   }
   ModelMoveSetter& operator=(ModelMoveSetter&& setter){
      viewModelController = std::move(setter.viewModelController);
      keyHandlers.clear();
      cursorHandlers.clear();
      createSetters();
      return *this;
   }
   ModelMoveSetter(ModelMoveSetter&& setter): viewModelController(std::move(setter.viewModelController)) {
      keyHandlers.clear();
      cursorHandlers.clear();
      createSetters();
   }
   // deleted copy semantic
   ModelMoveSetter& operator=(const ModelMoveSetter&) = delete;
   ModelMoveSetter(const ModelMoveSetter&) = delete;
   
};


} // namespace minecpp