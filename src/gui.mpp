export module gui;

import tool;
import <fmt>;
import <stl>;
import <gl>;
import <glm>;
import <imgui>;


export namespace minecpp
{
   
// need context first   
class GuiContext: public ProactiveSingleton<GuiContext>{
public:
   
   GuiContext(GLFWwindow* window, int majorVersion, int minorVersion){
      // imgui 准备阶段 : 
      // call ImGui::CreateContext()
      // call ImGui_ImplXXXX_Init() for each backend
      ImGui::CreateContext();
      // install_callbacks: 如果为true，则imgui会设置glfw的相关callback, 原来的callback（如果有）的函数指针会保存，imgui的callback会先调用
      ImGui_ImplGlfw_InitForOpenGL(window, true);
      std::string glslVersion = fmt::format("#version {}{}0", majorVersion, minorVersion);
      ImGui_ImplOpenGL3_Init(glslVersion.c_str());
   }
   ~GuiContext(){
      // 销毁阶段: 
      // call ImGui_ImplXXXX_Shutdown() for each backend 
      // call ImGui::DestroyContext()
      ImGui_ImplOpenGL3_Shutdown();
      ImGui_ImplGlfw_Shutdown();
      ImGui::DestroyContext();
   }
};

// need gui context first
class GuiFrame{
public:
   GuiFrame(){
      // frame 创建阶段: 
      // call ImGui_ImplXXXX_NewFrame() for each backend
      // call ImGui::NewFrame() 
      ImGui_ImplOpenGL3_NewFrame();
      ImGui_ImplGlfw_NewFrame();
      ImGui::NewFrame();
   }
   
   void render(){
      // render 阶段:  call ImGui::Render() and call ImGui_ImplXXXX_RenderDrawData() for Renderer backend
      ImGui::Render();
      ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
   }
};

inline void slider(const std::string& name, float& value, const float min = -50, const float max = 50){
   ImGui::SliderFloat(name.c_str(), &value, min, max);
}
inline void slider(const std::string& name, ObservableValue<float>& value, const float min = -50, const float max = 50){
   slider(name, value.get(), min, max);
   value.mayNotify();
}

inline void slider(const std::string& name, glm::vec3& value, const glm::vec3& min = glm::vec3{-5.0f}, const glm::vec3& max = glm::vec3{5.0f}){
   // 这种用法是正确的，因为一个右值的生命周期是其所在的整个表达式
   ImGui::SliderFloat(fmt::format("{}: {}", name, "x").c_str(), &value.x, min.x, max.x);
   ImGui::SliderFloat(fmt::format("{}: {}", name, "y").c_str(), &value.y, min.y, max.y);
   ImGui::SliderFloat(fmt::format("{}: {}", name, "z").c_str(), &value.z, min.z, max.z);
}
inline void slider(const std::string& name, ObservableValue<glm::vec3>& value, const glm::vec3& min = glm::vec3{-5.0f}, const glm::vec3& max = glm::vec3{5.0f}){
   slider(name, value.get(), min, max);
   value.mayNotify();
}


template<typename T>
void showPopup(T& t, std::map<T, std::string> elements){
   if (ImGui::Button("Select..")){
      ImGui::OpenPopup("my_select_popup");
   }
   ImGui::SameLine();
   ImGui::TextUnformatted(elements[t].c_str());
   if (ImGui::BeginPopup("my_select_popup")){
      ImGui::SeparatorText("Aquarium");
      for(auto& element: elements){
         if(ImGui::Selectable(element.second.c_str())){
            t = element.first;
         }
      }
      ImGui::EndPopup();
   }
}

class AbstractGuiWindow: public AutoLoader<AbstractGuiWindow>{
   RefContainer<AbstractGuiWindow>& getContainer();
public:
   AbstractGuiWindow():
      AutoLoader<AbstractGuiWindow>(getContainer()){}
   virtual void draw() = 0; 
};

template<typename Derived>
class GuiWindowBase: public AbstractGuiWindow{
private:
   RefOrConst<std::string> title;
   std::optional<bool*> open;
   void draw() override final{
      if(!open.has_value()){
         if(ImGui::Begin(title.get().c_str())){
            static_cast<Derived&>(*this).innerDraw();
         }
         ImGui::End();
      }else if(*open.value()){
         if(ImGui::Begin(title.get().c_str(), open.value())){
            static_cast<Derived&>(*this).innerDraw();
         }
         ImGui::End();
      }
   }
public:
   GuiWindowBase(RefOrConst<std::string> title, bool &open):
      title(std::move(title)), open(&open) {}
   GuiWindowBase(RefOrConst<std::string> title):
      title(std::move(title)), open(std::nullopt) {}

   std::string getTitle() const { return title; }
};

template<Callable<void(void)> FuncType>
class GuiWindowLoader: public GuiWindowBase<GuiWindowLoader<FuncType>>{
   friend GuiWindowBase<GuiWindowLoader>;
private:
   FuncType inner;
   
   void innerDraw(){
      inner();
   }
public:
   GuiWindowLoader(const RefOrConst<std::string>& title, bool &open, FuncType&& inner):
      GuiWindowBase<GuiWindowLoader<FuncType>>(title, open), inner(std::forward<decltype(inner)>(inner)){}
   GuiWindowLoader(const RefOrConst<std::string>& title, FuncType&& inner):
      GuiWindowBase<GuiWindowLoader<FuncType>>(title), inner(std::forward<decltype(inner)>(inner)){}
};

class GuiDrawer: public ProactiveSingleton<GuiDrawer>{
private:
   friend AbstractGuiWindow;
   RefContainer<AbstractGuiWindow> windows;
public:
   void draw(){
      GuiFrame frame;
      for(auto& window: windows){
         window.draw();
      }
      frame.render();
   }
};

inline RefContainer<AbstractGuiWindow>& AbstractGuiWindow::getContainer() {
   return GuiDrawer::getInstance().windows;
}

} // namespace minecpp
