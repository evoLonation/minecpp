module;

#include <stl>
#include <fmt>
#include <gl>
export module exception;


export namespace minecpp
{

// 不带参数直接调用即可
void logNestedException(const std::exception_ptr &eptr = std::current_exception(), size_t level = 0)
{
   auto get_nested = [](auto &e) -> std::exception_ptr {
      try { return dynamic_cast<const std::nested_exception &>(e).nested_ptr(); }
      catch (const std::bad_cast&) { return nullptr; }
   };
   try{
      if (eptr) std::rethrow_exception(eptr);
   }catch (const std::exception &e){
      std::cerr << std::string(level, ' ') << "exception: " << e.what() << '\n';
      logNestedException(get_nested(e), level + 1); // rewind all nested exception
   }
}

inline std::string printError(const std::string& error, const std::source_location location){
   return fmt::format("{}:{}:{} function `{}`: {}",
      location.file_name(),
      location.line(),
      location.column(),
      location.function_name(),
      error
   );
}

inline void logError(const std::string& error, const std::source_location location = std::source_location::current()){
   std::cout << printError(error, location) << std::endl;
}

// 最低一层用这个
inline void throwError(const std::string& error, const std::source_location location = std::source_location::current()){
   throw printError(error, location);
}

// 高层异常包装传递用这个
inline void throwWithNested(const std::string& msg, const std::source_location location = std::source_location::current()){
   std::throw_with_nested(std::runtime_error(printError(msg, location)));
}

inline void checkError(
   std::function<std::optional<std::string>()> errorGetter,
   std::function<void(void)> finalizer = nullptr,
   const std::source_location location = std::source_location::current()){
      auto error = errorGetter();
      if(error.has_value()){
         if(finalizer != nullptr)finalizer();
         throwError(error.value(), location);
      }
}

} // namespace minecpp